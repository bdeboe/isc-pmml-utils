Include %PMML

/// Utility methods for working with PMML
Class PMML.Interop.Utils
{

/// <p>Generates a BO dedicated to a specific PMML class, along with the corresponding request and response objects 
/// that refer explicitly to the model's input and output objects for conveniently mapping their properties in BPL.
/// The generated BO extends <Class>AbstractBusinessOperation</Class>.
/// If no target <Var>pPackage</Var> is provided, it will use the PMML class name as a package name.</p>
/// <p><b>Notes:</b>
/// <ul> 
///  <li>New classes overwrite existing ones in the target package without warning!</li>
///  <li>The generated request and response classes depend on a PMML serialization fix shipped with IRIS 2019.1</li>
/// </ul>
///</p>
ClassMethod GenerateOperation(pPMMLClass As %String, pPackage As %String = "") As %Status
{
	set tSC = $$$OK
	try {
		if '$$$defClassDefined(pPMMLClass) || '$classmethod(pPMMLClass,"%Extends","%DeepSee.PMML.Definition") {
			set tSC = $$$ERROR($$$GeneralError, "Class '"_pPMMLClass_"' is not a valid PMML class")
			quit
		}
		
		set:pPackage="" pPackage = pPMMLClass
		set tOperationClassName = pPackage_".Operation"
		
		set tBOClass = ##class(%Dictionary.ClassDefinition).%New()
		set tBOClass.Name = tOperationClassName
		set tBOClass.Super = "PMML.Interop.AbstractBusinessOperation"
		set tBOClass.Description = "Business Operation for PMML class "_pPMMLClass_" generated by "_$classname()
		set tBOClass.GeneratedBy = pPMMLClass
		set tBOClass.ProcedureBlock = 1
		
		set tSC = $classmethod(pPMMLClass, "%GetModels", .tModelInfo, 0)
		quit:$$$ISERR(tSC)
		
		set tMessageMap = ##class(%Dictionary.XDataDefinition).%New()
		set tMessageMap.parent = tBOClass
		set tMessageMap.Name = "MessageMap"
		do tMessageMap.Data.WriteLine("<MapItems>")
		
		for i = 1:1:tModelInfo {
			
			set tModelName = $lg(tModelInfo(i),1),
				tMethodName = $$$PROPERTYNAME(tModelName), 
				tModelClassName=$lg(tModelInfo(i),2)
			
			// create request & response messages
			set tReqClass = ##class(%Dictionary.ClassDefinition).%New()
			set tReqClass.Name = pPackage_".Msg."_tMethodName_"Req"
			set tReqClass.Super = "%Persistent,Ens.Request"
			set tReqClass.Description = "Request object for model "_tModelName_" in PMML class "_pPMMLClass
			set tReqClass.GeneratedBy = pPMMLClass
			set tReqClass.ProcedureBlock = 1
			set tPropDef = ##class(%Dictionary.PropertyDefinition).%New()
			set tPropDef.parent = tReqClass
			set tPropDef.Type = $parameter(tModelClassName,"INPUTCLASS")
			set tPropDef.Name = "Input"
			quit:$$$ISERR(tSC)
			set tCompile(tReqClass.Name)=tReqClass
			
			set tRespClass = ##class(%Dictionary.ClassDefinition).%New()
			set tRespClass.Name = pPackage_".Msg."_tMethodName_"Resp"
			set tRespClass.Super = "Ens.Response"
			set tRespClass.Description = "Response object for model "_tModelName_" in PMML class "_pPMMLClass
			set tRespClass.GeneratedBy = pPMMLClass
			set tRespClass.ProcedureBlock = 1
			set tPropDef = ##class(%Dictionary.PropertyDefinition).%New()
			set tPropDef.parent = tRespClass
			set tPropDef.Type = $parameter(tModelClassName,"OUTPUTCLASS")
			set tPropDef.Name = "Output"
			quit:$$$ISERR(tSC)
			set tCompile(tRespClass.Name)=tRespClass
			
			
			// write MessageMap entry
			do tMessageMap.Data.WriteLine("<MapItem MessageType="""_tReqClass.Name_""">")
			do tMessageMap.Data.WriteLine("<Method>"_tMethodName_"</Method>")
			do tMessageMap.Data.WriteLine("</MapItem>")
			
			
			// create method
			set tMethod = ##class(%Dictionary.MethodDefinition).%New()
			set tMethod.parent = tBOClass
			set tMethod.Name = tMethodName
			set tMethod.FormalSpec = "pRequest:"_tReqClass.Name_",*pResponse:"_tRespClass.Name
			set tMethod.ReturnType = "%Status"
			do tMethod.Implementation.WriteLine("	set tSC = ..InvokeModel("_$$$QUOTE(tMethodName)_", pRequest.Input, .tModelOutput)")
			do tMethod.Implementation.WriteLine("	set pResponse = ##class("_tRespClass.Name_").%New()")
			do tMethod.Implementation.WriteLine("	set pResponse.Output = $g(tModelOutput)")
			do tMethod.Implementation.WriteLine("	quit tSC")
		}
		
		do tMessageMap.Data.WriteLine("</MapItems>")
		
		// add GetModelInstance() method
		set tMethod = ##class(%Dictionary.MethodDefinition).%New()
		set tMethod.parent = tBOClass
		set tMethod.Name = "GetModelInstance"
		set tMethod.FormalSpec = "pModelName:%String,*pModel:%DeepSee.PMML.Model.AbstractModel"
		set tMethod.Private = 1
		set tMethod.ReturnType = "%Status"
		do tMethod.Implementation.WriteLine("	quit ##class("_pPMMLClass_").%GetModelInstance(pModelName, .pModel)")
		
		
		// first delete old objects
		set:$$$defClassDefined(tBOClass.Name) tDelete(tBOClass.Name)=""
		set tClassName = ""
		for {
			set tClassName = $order(tCompile(tClassName))
			quit:tClassName=""
			set:$$$defClassDefined(tClassName) tDelete(tClassName)=""
		}
		quit:$$$ISERR(tSC)
		set:$d(tDelete) tSC = $system.OBJ.Delete(.tDelete, "-d")
		quit:$$$ISERR(tSC)
		
		
		// then save new ones and compile
		set i = ""
		for {
			set i = $order(tCompile(i), 1, tCompileObj)
			quit:i=""
			set tSC = tCompileObj.%Save()
			quit:$$$ISERR(tSC)
		}
		quit:$$$ISERR(tSC)
		set tSC = tBOClass.%Save()
		quit:$$$ISERR(tSC)
		set tCompile(tBOClass.Name)=""
		set tSC = $system.OBJ.Compile(.tCompile, "crkf")
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
}
}